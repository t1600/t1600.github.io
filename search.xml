<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python poetry 教程</title>
      <link href="/2025/04/05/poetry%E6%95%99%E7%A8%8B/"/>
      <url>/2025/04/05/poetry%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="poetry用法"><a href="#poetry用法" class="headerlink" title="poetry用法"></a>poetry用法</h3><p><strong>初始化项目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry init </span><br></pre></td></tr></table></figure><p><strong>创建虚拟环境</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry env use python</span><br></pre></td></tr></table></figure><p><strong>虚拟环境的位置可设置在项目目录下(全局生效)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry config virtualenvs.in-project true</span><br></pre></td></tr></table></figure><p><strong>删除虚拟环境</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry env remove python</span><br></pre></td></tr></table></figure><p><strong>如果poetry的版本大于2.0，需要安装</strong><code>poetry-plugin-shell</code><strong>插件，才能使用</strong><code>poetry shell</code><strong>命令(全局生效)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry self add poetry-plugin-shell</span><br></pre></td></tr></table></figure><p><strong>进入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry shell</span><br></pre></td></tr></table></figure><p><strong>退出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong>添加包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poetry add</span><br><span class="line"></span><br><span class="line">poetry add fastapi==0.0.1</span><br></pre></td></tr></table></figure><p><strong>将</strong> <code>pyproject.toml</code><strong>更新到</strong> <code>poetry.lock</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry lock</span><br></pre></td></tr></table></figure><p><strong>更新包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry update</span><br></pre></td></tr></table></figure><p><strong>查看包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry show</span><br></pre></td></tr></table></figure><p><strong>移除包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry remove flask</span><br></pre></td></tr></table></figure><p><strong>换源</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry source add --priority=primary mirrors https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python工具Ruff教程</title>
      <link href="/2025/04/04/Ruff%E6%95%99%E7%A8%8B/"/>
      <url>/2025/04/04/Ruff%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>Ruff</strong> 是一个用 Rust 编写的极其快速的 Python linter 和代码格式化工具。它的目标是成为现有 Python 工具（如 Flake8、isort、pydocstyle、pyupgrade、autoflake 等）的替代品，并将它们的功能整合到一个高效的工具中。</p><p><strong>Ruff 的主要优点：</strong></p><ul><li><strong>速度极快</strong>：比现有的 linter（如 Flake8 + 插件）快 10-100 倍。</li><li><strong>单一工具</strong>：集成了 linting、格式化、导入排序、现代化语法等多项功能。</li><li><strong>兼容性</strong>：支持 <code>pyproject.toml</code> 配置，并能识别 Flake8 的配置。</li><li><strong>自动修复</strong>：支持对大量 linting 规则进行自动修复。</li><li><strong>内置缓存</strong>：避免对未更改的文件重复分析。</li><li><strong>活跃开发</strong>：项目持续更新，不断添加新规则和功能。</li></ul><p><strong>1. 安装 Ruff</strong></p><p>推荐使用 <code>pip</code> 来安装 Ruff：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ruff</span><br></pre></td></tr></table></figure><p>或者，如果你使用 <code>pipx</code>（推荐用于安装命令行工具）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx install ruff</span><br></pre></td></tr></table></figure><p>你也可以通过其他包管理器（如 Conda、Homebrew）安装，具体请参考 Ruff 官方文档。</p><p><strong>2. 基本用法</strong></p><ul><li><strong>检查代码（Linting）</strong></li></ul><p>   在你的项目根目录下运行：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruff check .</span><br></pre></td></tr></table></figure><p>   这会检查当前目录及其子目录下的所有 Python 文件。Ruff 会输出发现的问题，包括文件路径、行号、列号、规则代码和问题描述。</p><p>   例如：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/my_module.py:5:1: F841 Local variable `x` is assigned to but never used</span><br><span class="line">src/my_module.py:10:80: E501 Line too long (88 &gt; 79 characters)</span><br><span class="line">Found 2 errors.</span><br><span class="line">[*] 1 potentially fixable with the --fix option.</span><br></pre></td></tr></table></figure></p><ul><li><strong>自动修复</strong></li></ul><p>   Ruff 可以自动修复许多检测到的问题。使用 <code>--fix</code> 标志：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruff check . --fix</span><br></pre></td></tr></table></figure><p>   Ruff 会修改文件以修复可修复的问题。对于无法自动修复的问题，它仍会显示出来。</p><ul><li><strong>格式化代码（Formatting）</strong></li></ul><p>   Ruff 包含一个与 Black 兼容的代码格式化工具。运行：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruff format .</span><br></pre></td></tr></table></figure><p>   这会根据配置的样式格式化项目中的 Python 文件。</p><ul><li><strong>检查并格式化</strong></li></ul><p>   你可以一次性运行检查和格式化：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruff .</span><br></pre></td></tr></table></figure><p>   这等同于先运行 <code>ruff format .</code> 再运行 <code>ruff check . --fix</code>。</p><ul><li><strong>查看可用规则</strong></li></ul>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruff rule --all</span><br></pre></td></tr></table></figure><ul><li><strong>解释特定规则</strong></li></ul>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruff rule F841</span><br></pre></td></tr></table></figure><p>   这会显示规则 F841 (Unused variable) 的详细解释。</p><p><strong>3. 配置 Ruff</strong></p><p>Ruff 主要通过项目根目录下的 <code>pyproject.toml</code> 文件或独立的 <code>ruff.toml</code> 文件进行配置。推荐使用 <code>pyproject.toml</code>，因为它也是许多其他 Python 工具（如 Poetry, Black, Pytest）的标准配置文件。</p><p>在 <code>pyproject.toml</code> 中，Ruff 的配置位于 <code>[tool.ruff]</code> 部分。</p><p>**基本配置示例 (<code>pyproject.toml</code>)**：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.ruff]</span></span><br><span class="line"><span class="comment"># 设置目标 Python 版本 (例如 &quot;py310&quot; 代表 Python 3.10)</span></span><br><span class="line"><span class="comment"># 这会影响一些代码升级和语法检查规则</span></span><br><span class="line"><span class="attr">target-version</span> = <span class="string">&quot;py310&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择要启用的规则代码或前缀</span></span><br><span class="line"><span class="comment"># F: Pyflakes, E/W: pycodestyle, I: isort, U: pyupgrade, B: flake8-bugbear 等</span></span><br><span class="line"><span class="comment"># 默认启用 F, E, W</span></span><br><span class="line"><span class="attr">select</span> = [<span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;U&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略特定的规则</span></span><br><span class="line"><span class="attr">ignore</span> = [<span class="string">&quot;E501&quot;</span>] <span class="comment"># 例如, 忽略行过长错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要排除检查的文件或目录模式</span></span><br><span class="line"><span class="attr">exclude</span> = [</span><br><span class="line">    <span class="string">&quot;.bzr&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.direnv&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.eggs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.git&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.hg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.mypy_cache&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.nox&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.pants.d&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.pytype&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.ruff_cache&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.svn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.tox&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.venv&quot;</span>,</span><br><span class="line">    <span class="string">&quot;__pypackages__&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;buck-out&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="string">&quot;venv&quot;</span>,</span><br><span class="line">    <span class="string">&quot;migrations/&quot;</span>, <span class="comment"># 忽略 Django migrations 目录</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每行的最大长度 (用于 E501 和格式化)</span></span><br><span class="line"><span class="attr">line-length</span> = <span class="number">88</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅启用可自动修复的规则子集进行修复</span></span><br><span class="line"><span class="comment"># fixable = [&quot;A&quot;, &quot;B&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从自动修复中排除特定规则</span></span><br><span class="line"><span class="comment"># unfixable = [&quot;B&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [tool.ruff.lint] # (可选) Linting 相关的特定配置可以放在这里</span></span><br><span class="line"><span class="comment"># select = [&quot;E&quot;, &quot;F&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [tool.ruff.format] # (可选) Formatter 相关的特定配置可以放在这里</span></span><br><span class="line"><span class="comment"># quote-style = &quot;double&quot; # 使用双引号而非单引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定插件的配置 (例如 isort)</span></span><br><span class="line"><span class="section">[tool.ruff.lint.isort]</span></span><br><span class="line"><span class="attr">known-first-party</span> = [<span class="string">&quot;my_package&quot;</span>] <span class="comment"># 将 &#x27;my_package&#x27; 视为第一方库</span></span><br><span class="line"><span class="comment"># required-imports = [&quot;from __future__ import annotations&quot;] # 强制添加某个导入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pyupgrade 配置</span></span><br><span class="line"><span class="section">[tool.ruff.lint.pyupgrade]</span></span><br><span class="line"><span class="comment"># 保留 Python 3.9 以下版本的类型注解 (如果 target-version &lt; &quot;py310&quot;)</span></span><br><span class="line"><span class="attr">keep-runtime-typing</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>关键配置选项说明:</strong></p><ul><li><code>target-version</code>: 非常重要，确保 Ruff 根据你项目使用的 Python 版本应用正确的规则。</li><li><code>select</code>: 启用规则集合。你可以使用前缀（如 <code>F</code> 代表 Pyflakes 的所有规则）或具体代码（如 <code>F841</code>）。查看 Ruff 文档获取完整的规则列表。</li><li><code>ignore</code>: 禁用特定的规则。</li><li><code>exclude</code>: 排除不需要检查或格式化的文件&#x2F;目录。默认已包含常见的虚拟环境、版本控制和缓存目录。</li><li><code>line-length</code>: 设置代码行的最大长度，影响 <code>E501</code> 规则和 <code>ruff format</code>。</li><li><code>fixable</code>&#x2F;<code>unfixable</code>: 更精细地控制哪些规则参与自动修复。</li><li>插件配置 (<code>[tool.ruff.lint.&lt;plugin_name&gt;]</code>)：为特定的规则集（如 isort, pydocstyle）提供更详细的配置。</li></ul><p><strong>4. 常用规则和插件</strong></p><p>Ruff 内置支持并重新实现了许多流行的 Flake8 插件和独立工具的规则，包括：</p><ul><li><strong>Pyflakes (F)</strong>: 检测基本错误，如未使用的导入、未定义的变量。</li><li><strong>pycodestyle (E, W)</strong>: 检查代码风格是否符合 PEP 8 指南（缩进、空格、命名等）。</li><li><strong>isort (I)</strong>: 对导入进行排序和分组。</li><li><strong>pyupgrade (U)</strong>: 升级到更现代的 Python 语法。</li><li><strong>flake8-bugbear (B)</strong>: 检测可能的逻辑错误和可疑代码。</li><li><strong>flake8-comprehensions (C4)</strong>: 鼓励使用更简洁的推导式。</li><li><strong>flake8-simplify (SIM)</strong>: 简化复杂的代码结构。</li><li><strong>pydocstyle (D)</strong>: 检查文档字符串（docstrings）的风格。</li><li>… 等等，支持的规则集在不断增加。</li></ul><p><strong>示例：Ruff 检测和修复</strong></p><ul><li><p><strong>未使用的导入 (F401)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os <span class="comment"># Ruff: F401 `os` imported but unused</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>ruff check . --fix</code> 会自动删除 <code>import os</code> 这一行。</p></li><li><p><strong>导入排序 (I)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os <span class="comment"># Ruff: I001 Import block is un-sorted or un-formatted</span></span><br></pre></td></tr></table></figure><p><code>ruff check . --fix</code> 或 <code>ruff format .</code> 会将其重新排序为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure></li><li><p><strong>现代语法 (U)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 target-version &gt;= &quot;py36&quot;</span></span><br><span class="line">my_string = <span class="string">&quot;Value: %s&quot;</span> % value <span class="comment"># Ruff: UP031 Use format specifiers instead of %-style formatting</span></span><br></pre></td></tr></table></figure><p><code>ruff check . --fix</code> 会将其改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_string = <span class="string">f&quot;Value: <span class="subst">&#123;value&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>5. 集成</strong></p><ul><li><p><strong>编辑器集成</strong></p><ul><li><strong>VS Code</strong>: 安装官方的 <a href="https://marketplace.visualstudio.com/items?itemName=charliermarsh.ruff">Ruff VS Code 插件</a>。它可以在你编写代码时实时显示 linting 问题，并提供格式化和快速修复功能。通常需要在 VS Code 的设置 (settings.json) 中启用 Ruff 作为格式化工具和 linter。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;[python]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;charliermarsh.ruff&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 可选：保存时自动格式化</span></span><br><span class="line">    <span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;explicit&quot;</span><span class="punctuation">,</span> <span class="comment">// 可选：保存时运行 Ruff 的自动修复 (可以设为 true 自动修复)</span></span><br><span class="line">      <span class="attr">&quot;source.organizeImports&quot;</span><span class="punctuation">:</span> <span class="string">&quot;explicit&quot;</span> <span class="comment">// 可选: 保存时自动整理 import</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ruff.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// &quot;ruff.fixAll&quot;: true, // 如果希望保存时总是执行 --fix</span></span><br><span class="line">  <span class="comment">// &quot;ruff.organizeImports&quot;: true // 如果希望保存时总是整理 imports</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>PyCharm&#x2F;IntelliJ</strong>: Ruff 可以作为 <a href="https://ruff.rs/docs/integrations/#pycharm">外部工具</a> 集成。或者使用 File Watchers 插件在文件保存时自动运行 Ruff。社区也有一些 Ruff 插件可用。</li></ul></li><li><p><strong>预提交钩子 (Pre-commit Hooks)</strong><br>使用 <code>pre-commit</code> 可以在提交代码前自动运行 Ruff。在你的 <code>.pre-commit-config.yaml</code> 文件中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line"><span class="bullet">-</span>   <span class="attr">repo:</span> <span class="string">https://github.com/astral-sh/ruff-pre-commit</span></span><br><span class="line">    <span class="comment"># 根据需要选择 Ruff 的版本</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v0.4.1</span> <span class="comment"># 使用最新的稳定版 tag</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">        <span class="comment"># 同时运行 linter 和 formatter</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff</span></span><br><span class="line">          <span class="attr">args:</span> [<span class="string">--fix</span>] <span class="comment"># 可选: 启用自动修复</span></span><br><span class="line">        <span class="comment"># 或者, 分开运行 formatter 和 linter</span></span><br><span class="line">        <span class="comment"># - id: ruff-format</span></span><br><span class="line">        <span class="comment"># - id: ruff</span></span><br><span class="line">        <span class="comment">#   args: [--fix]</span></span><br></pre></td></tr></table></figure><p>然后运行 <code>pre-commit install</code> 来安装钩子。</p></li><li><p><strong>CI&#x2F;CD (例如 GitHub Actions)</strong><br>在你的 CI 工作流程中添加一个步骤来运行 Ruff，确保合并到主分支的代码是符合规范的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Ruff</span> <span class="string">Check</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>, <span class="string">pull_request</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">ruff:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-python@v5</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">python-version:</span> <span class="string">&#x27;3.10&#x27;</span> <span class="comment"># 选择你的项目 Python 版本</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Ruff</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">ruff</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Ruff</span> <span class="string">Linter</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">ruff</span> <span class="string">check</span> <span class="string">.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Ruff</span> <span class="string">Formatter</span> <span class="string">Check</span> <span class="string">(Optional)</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">ruff</span> <span class="string">format</span> <span class="string">.</span> <span class="string">--check</span> <span class="comment"># --check 只检查不修改，CI 中常用</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>6. 总结</strong></p><p>Ruff 是一个强大、快速且易于使用的 Python 工具，可以显著提高代码质量和开发效率。通过整合多种检查和格式化功能，它可以简化你的开发工作流和 CI&#x2F;CD 配置。强烈建议尝试将其集成到你的 Python 项目中。</p><p>希望这个教程对你有所帮助！如果你有任何具体的问题，随时可以提问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Python </tag>
            
            <tag> Ruff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile 教程</title>
      <link href="/2025/04/04/Dockerfile%E6%95%99%E7%A8%8B/"/>
      <url>/2025/04/04/Dockerfile%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>什么是 Dockerfile？</strong></p><p>Dockerfile 是一个文本文件，它包含了一系列用户可以调用命令行来自动构建 Docker 镜像的指令。简单来说，Dockerfile 就是构建镜像的“说明书”或“配方”。通过 <code>docker build</code> 命令，Docker 可以读取 Dockerfile 中的指令，并按顺序执行，最终生成一个自定义的 Docker 镜像。</p><p><strong>Dockerfile 基本结构和常用指令</strong></p><p>一个典型的 Dockerfile 通常包含以下几个部分，并按特定顺序组织：</p><ol><li><p><strong><code>FROM</code> - 指定基础镜像:</strong></p><ul><li>每个 Dockerfile 的第一条非注释指令<strong>必须</strong>是 <code>FROM</code>。</li><li>它指定了你构建新镜像所依赖的基础镜像。例如，如果你要构建一个运行 Python 应用的镜像，可能会选择一个官方的 Python 镜像作为基础。</li><li>语法：<code>FROM &lt;image&gt;:&lt;tag&gt;</code> 或 <code>FROM &lt;image&gt;@&lt;digest&gt;</code></li><li>示例：<code>FROM python:3.9-slim</code> 或 <code>FROM ubuntu:22.04</code></li></ul></li><li><p><strong><code>LABEL</code> - 添加元数据 (可选):</strong></p><ul><li>用于为镜像添加元数据，如维护者信息、版本号等。</li><li>语法：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li><li>示例：<code>LABEL maintainer=&quot;Your Name &lt;your.email@example.com&gt;&quot;</code></li></ul></li><li><p><strong><code>ARG</code> - 定义构建时变量 (可选):</strong></p><ul><li>定义在 <code>docker build</code> 命令执行时可以传递给构建过程的变量。注意，<code>ARG</code> 定义的变量在镜像构建完成后通常不可用，除非它被 <code>ENV</code> 指令使用。</li><li>语法：<code>ARG &lt;name&gt;[=&lt;default value&gt;]</code></li><li>示例：<code>ARG APP_VERSION=1.0</code></li></ul></li><li><p><strong><code>ENV</code> - 设置环境变量:</strong></p><ul><li>设置环境变量。这些变量在镜像构建过程中以及基于该镜像启动的容器中都可用。</li><li>语法：<code>ENV &lt;key&gt;=&lt;value&gt;</code> 或 <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></li><li>示例：<code>ENV PYTHONDONTWRITEBYTECODE=1</code> (阻止 Python 生成 .pyc 文件)</li><li>示例：<code>ENV APP_HOME=/app</code></li></ul></li><li><p><strong><code>WORKDIR</code> - 设置工作目录:</strong></p><ul><li>为后续的 <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code>, <code>ADD</code> 指令设置工作目录。如果目录不存在，<code>WORKDIR</code> 会自动创建它。</li><li>推荐使用绝对路径。</li><li>语法：<code>WORKDIR /path/to/workdir</code></li><li>示例：<code>WORKDIR /app</code> (后续指令将在 <code>/app</code> 目录下执行)</li></ul></li><li><p><strong><code>COPY</code> &#x2F; <code>ADD</code> - 复制文件或目录:</strong></p><ul><li><code>COPY</code>: 将构建上下文（通常是 Dockerfile 所在的目录及其子目录）中的文件或目录复制到镜像的文件系统中。<ul><li>语法：<code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li><li>示例：<code>COPY . .</code> (将当前目录所有内容复制到镜像的当前工作目录)</li><li>示例：<code>COPY requirements.txt /app/</code></li></ul></li><li><code>ADD</code>: 功能与 <code>COPY</code> 类似，但增加了两个额外功能：<ul><li>源 <code>&lt;src&gt;</code> 可以是 URL。</li><li>如果源 <code>&lt;src&gt;</code> 是一个可识别的压缩格式（如 tar, gzip, bzip2, xz），它会被自动解压缩到目标 <code>&lt;dest&gt;</code>。</li><li><strong>注意：</strong> 除非明确需要 <code>ADD</code> 的特殊功能（如解压或下载 URL），否则官方推荐优先使用 <code>COPY</code>，因为它的行为更明确、可预测。</li><li>语法：<code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li><li>示例：<code>ADD https://example.com/file.tar.gz /tmp/</code> (下载并解压)</li></ul></li></ul></li><li><p><strong><code>RUN</code> - 执行构建命令:</strong></p><ul><li>在镜像构建过程中执行指定的命令。通常用于安装软件包、创建目录、编译代码等。</li><li>每条 <code>RUN</code> 指令都会在当前镜像的顶层创建一个新的层。为了减少镜像层数，通常建议将多个相关的命令合并到一条 <code>RUN</code> 指令中，使用 <code>&amp;&amp;</code> 连接。</li><li>有两种格式：<ul><li>Shell 格式：<code>RUN &lt;command&gt;</code> (命令在 shell 中执行，通常是 <code>/bin/sh -c</code>)</li><li>Exec 格式：<code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (直接执行，不通过 shell)</li></ul></li><li>示例（Shell 格式）：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">    package1 \</span></span><br><span class="line"><span class="language-bash">    package2 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure></li><li>示例（Exec 格式，较少用于 <code>RUN</code>）：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;apt-get&quot;</span>, <span class="string">&quot;update&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>EXPOSE</code> - 声明端口:</strong></p><ul><li>声明容器在运行时打算监听的网络端口。这<strong>不会</strong>实际发布端口，只是作为文档告诉用户（或自动化工具）哪些端口是有意暴露的。</li><li>实际发布端口需要在 <code>docker run</code> 时使用 <code>-p</code> 或 <code>-P</code> 参数。</li><li>语法：<code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code> (默认协议是 TCP)</li><li>示例：<code>EXPOSE 8080</code> 或 <code>EXPOSE 80/tcp 53/udp</code></li></ul></li><li><p><strong><code>VOLUME</code> - 定义匿名卷 (可选):</strong></p><ul><li>创建一个指定名称的挂载点，并将其标记为持有来自外部挂载的卷或来自其他容器的卷。常用于数据库存储、日志文件等需要持久化或共享的数据。</li><li>语法：<code>VOLUME [&quot;/path/to/volume&quot;]</code></li><li>示例：<code>VOLUME [&quot;/var/log&quot;, &quot;/data&quot;]</code></li></ul></li><li><p><strong><code>USER</code> - 设置运行用户 (可选):</strong></p><ul><li>指定运行后续 <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code> 指令时使用的用户名或 UID（以及可选的组名或 GID）。</li><li>为了安全起见，推荐在不需要 root 权限时切换到非 root 用户。</li><li>语法：<code>USER &lt;user&gt;[:&lt;group&gt;]</code> 或 <code>USER &lt;UID&gt;[:&lt;GID&gt;]</code></li><li>示例：<code>RUN useradd -ms /bin/bash myuser</code></li><li>示例：<code>USER myuser</code></li></ul></li><li><p><strong><code>ENTRYPOINT</code> - 配置容器启动时执行的命令:</strong></p><ul><li>允许你将容器配置为像可执行文件一样运行。</li><li><code>ENTRYPOINT</code> 指定的命令不容易在容器启动时被覆盖（除非使用 <code>docker run --entrypoint</code>）。</li><li>通常与 <code>CMD</code> 配合使用，<code>CMD</code> 提供 <code>ENTRYPOINT</code> 的默认参数。</li><li>有两种格式：<ul><li>Exec 格式（推荐）：<code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li><li>Shell 格式：<code>ENTRYPOINT command param1 param2</code> (会在 <code>/bin/sh -c</code> 中执行，可能导致无法接收信号和 PID 1 问题，一般不推荐)</li></ul></li><li>示例（Exec 格式）：<code>ENTRYPOINT [&quot;python&quot;, &quot;app.py&quot;]</code></li></ul></li><li><p><strong><code>CMD</code> - 提供容器启动的默认命令或参数:</strong></p><ul><li><code>CMD</code> 指令有三种用途：<ul><li>为 <code>ENTRYPOINT</code> 指令提供默认参数。</li><li>如果 Dockerfile 中没有 <code>ENTRYPOINT</code>，则 <code>CMD</code> 指定容器启动时要执行的默认命令。</li><li>如果在 <code>docker run</code> 命令中指定了其他命令，<code>CMD</code> 的值会被覆盖。</li></ul></li><li>一个 Dockerfile 中只能有一条 <code>CMD</code> 指令生效。如果有多条，只有最后一条会生效。</li><li>有三种格式：<ul><li>Exec 格式（推荐，尤其是在没有 <code>ENTRYPOINT</code> 或作为 <code>ENTRYPOINT</code> 参数时）：<code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></li><li>作为 <code>ENTRYPOINT</code> 的默认参数：<code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code></li><li>Shell 格式：<code>CMD command param1 param2</code></li></ul></li><li>示例（配合 <code>ENTRYPOINT</code>）：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="comment"># 提供默认配置文件参数</span></span></span><br></pre></td></tr></table></figure></li><li>示例（独立使用，提供默认执行命令）：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li>示例（Shell 格式）：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello Docker&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>.dockerignore</code> 文件:</strong></p><ul><li>这不是 Dockerfile 的一部分，但在构建镜像时非常重要。</li><li>它是一个位于构建上下文根目录（通常和 Dockerfile 在同一目录）的文件，用于指定在执行 <code>docker build</code> 时哪些文件或目录不应被发送到 Docker 守护进程（即不包含在构建上下文中）。</li><li>语法类似于 <code>.gitignore</code>。</li><li>这有助于减小构建上下文的大小，加快构建速度，并避免将敏感信息或不必要的文件复制到镜像中。</li><li>示例 <code>.dockerignore</code> 内容：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">*.log</span><br><span class="line">Dockerfile</span><br><span class="line">.dockerignore</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>编写 Dockerfile 的最佳实践</strong></p><ol><li><p><strong>保持镜像尽可能小:</strong></p><ul><li>选择合适的基础镜像（如 <code>alpine</code>, <code>slim</code> 版本）。</li><li>只安装必要的软件包。</li><li>清理不必要的文件，例如在 <code>RUN</code> 指令的最后清理包管理器的缓存（如 <code>apt-get clean</code>, <code>rm -rf /var/lib/apt/lists/*</code>）。</li><li>使用多阶段构建（Multi-stage builds）。</li></ul></li><li><p><strong>利用构建缓存:</strong></p><ul><li>Docker 会缓存 <code>RUN</code>, <code>COPY</code>, <code>ADD</code> 等指令的结果层。</li><li>将不经常变化的指令（如安装基础依赖）放在 Dockerfile 的前面。</li><li>将经常变化的指令（如 <code>COPY</code> 应用程序代码）放在后面。</li><li>例如，先 <code>COPY</code> 依赖文件（如 <code>requirements.txt</code> 或 <code>package.json</code>）并安装依赖，然后再 <code>COPY</code> 整个应用程序代码。</li></ul></li><li><p><strong>合并 <code>RUN</code> 指令:</strong></p><ul><li>每条 <code>RUN</code> 指令都会创建一个新的镜像层。过多的层会增加镜像大小。</li><li>使用 <code>&amp;&amp;</code> 将多个命令连接在一条 <code>RUN</code> 指令中。</li></ul></li><li><p><strong>使用 <code>.dockerignore</code>:</strong></p><ul><li>排除不需要发送到 Docker 守护进程的文件和目录。</li></ul></li><li><p><strong>优先使用 <code>COPY</code> 而不是 <code>ADD</code>:</strong></p><ul><li>除非你需要 <code>ADD</code> 的特定功能（URL 下载或自动解压），否则 <code>COPY</code> 更清晰、更可预测。</li></ul></li><li><p><strong>使用多阶段构建 (Multi-stage Builds):</strong></p><ul><li>对于需要编译步骤的应用程序（如 Go, Java, C++），可以在一个阶段（构建阶段）进行编译和构建，然后在另一个更小的阶段（运行阶段）只复制编译后的产物和必要的运行时依赖。这可以显著减小最终镜像的大小。</li><li>示例结构：<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---- Build Stage ----</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o myapp .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- Runtime Stage ----</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/myapp .</span></span><br><span class="line"><span class="comment"># Copy other necessary files like configs if needed</span></span><br><span class="line"><span class="comment"># COPY --from=builder /app/config.yaml .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./myapp&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用 <code>Exec</code> 格式的 <code>CMD</code> 和 <code>ENTRYPOINT</code>:</strong></p><ul><li>避免使用 Shell 格式，因为它会隐式启动一个 shell 进程 (<code>/bin/sh -c</code>)，这可能导致信号处理问题（例如，<code>docker stop</code> 可能无法正常停止应用）并且你的应用不会是 PID 1。</li></ul></li><li><p><strong>以非 Root 用户运行:</strong></p><ul><li>增加安全性，避免容器内的进程拥有宿主机的 root 权限。使用 <code>USER</code> 指令切换用户。</li></ul></li><li><p><strong>明确指定包版本:</strong></p><ul><li>在 <code>RUN</code> 指令中安装软件包时，尽可能指定版本号，以确保构建的可重复性。</li></ul></li><li><p><strong>添加 <code>LABEL</code>:</strong></p><ul><li>提供镜像的元数据，方便管理和理解。</li></ul></li></ol><p><strong>简单示例：一个 Python Flask 应用的 Dockerfile</strong></p><p>假设你的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.py</span><br><span class="line">├── requirements.txt</span><br><span class="line">└── Dockerfile</span><br></pre></td></tr></table></figure><p><code>requirements.txt</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flask==2.1.2</span><br></pre></td></tr></table></figure><p><code>app.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, Docker!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用官方 Python 运行时作为父镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 设置环境变量 (可选，但推荐)</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONDONTWRITEBYTECODE <span class="number">1</span> <span class="comment"># 阻止 Python 写入 .pyc 文件</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED <span class="number">1</span>      <span class="comment"># 让 Python 输出直接发送到终端，方便查看日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 复制依赖文件并安装依赖 (利用缓存)</span></span><br><span class="line"><span class="comment"># 只复制 requirements.txt，如果它没有变化，则下面安装的层会被缓存</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 复制项目代码到工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 声明应用监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. (可选) 创建非 root 用户并切换</span></span><br><span class="line"><span class="comment"># RUN useradd -m myuser</span></span><br><span class="line"><span class="comment"># USER myuser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 定义容器启动时运行的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>如何构建镜像</strong></p><p>在包含 <code>Dockerfile</code> 和你的应用程序代码的目录下，打开终端，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t 参数用于给镜像打标签 (name:tag)</span></span><br><span class="line"><span class="comment"># . 表示使用当前目录作为构建上下文</span></span><br><span class="line">docker build -t my-python-app:latest .</span><br></pre></td></tr></table></figure><p>构建成功后，你就可以使用这个镜像来运行容器了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p 参数将宿主机的 8080 端口映射到容器的 5000 端口</span></span><br><span class="line">docker run -p 8080:5000 my-python-app:latest</span><br></pre></td></tr></table></figure><p>现在，访问 <code>http://localhost:8080</code> 应该就能看到 “Hello, Docker!” 了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python uv 教程</title>
      <link href="/2025/04/04/uv%E6%95%99%E7%A8%8B/"/>
      <url>/2025/04/04/uv%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="uv-是什么："><a href="#uv-是什么：" class="headerlink" title="uv 是什么："></a><strong><code>uv</code> 是什么：</strong></h3><p><code>uv</code> 是一个用 Rust 编写的、速度极快的 Python 包安装器和解析器，由 Astral 公司（也就是 <code>ruff</code> 的开发者）开发。它的目标是成为 <code>pip</code> 和 <code>pip-tools</code> 的直接替代品，并提供更快、更友好的用户体验。<code>uv</code> 还集成了虚拟环境管理的功能，类似于 <code>venv</code> 或 <code>conda</code>。</p><p><strong><code>uv</code> 的主要特点：</strong></p><ol><li><strong>极速:</strong> 由于使用 Rust 编写并采用了先进的并发和缓存策略，<code>uv</code> 在安装、解析依赖关系时通常比 <code>pip</code> 快得多（官方宣称快 10-100 倍）。</li><li><strong>集成工具:</strong> 它将包安装（类似 <code>pip</code>）、依赖锁定（类似 <code>pip-compile</code>）和虚拟环境管理（类似 <code>venv</code>）结合在一个工具中。</li><li><strong><code>pip</code> 兼容性:</strong> 它的 <code>uv pip</code> 命令设计为 <code>pip</code> 命令的直接替代品，大部分常用命令和参数都兼容。</li><li><strong>先进的依赖解析:</strong> 使用 PubGrub 算法进行依赖解析，与 <code>pip</code> 的回溯解析器类似但速度更快。</li><li><strong>全局缓存:</strong> 默认启用全局包缓存，避免重复下载。</li><li><strong>跨平台:</strong> 支持 macOS, Linux, 和 Windows。</li></ol><p>下面是如何安装和使用 <code>uv</code> 的详细步骤：</p><h4 id="快速开始："><a href="#快速开始：" class="headerlink" title="快速开始："></a>快速开始：</h4><p><strong>Python 版本管理</strong></p><p>安装和管理 <code>Python</code> 版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uv python install：安装 Python 版本。</span><br><span class="line">uv python list：查看可用的 Python 版本。</span><br><span class="line">uv python find：查找已安装的 Python 版本。</span><br><span class="line">uv python pin：为当前项目指定使用的 Python 版本。</span><br><span class="line">uv python uninstall：卸载 Python 版本。</span><br></pre></td></tr></table></figure><p><strong>项目</strong></p><p>创建并管理包含 <code>pyproject.toml</code> 的 <code>Python</code>项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uv init：创建一个新项目。</span><br><span class="line">uv add：向项目添加依赖。</span><br><span class="line">uv remove：从项目中移除依赖。</span><br><span class="line">uv sync：同步项目依赖到环境。</span><br><span class="line">uv lock：为项目依赖创建锁文件。</span><br><span class="line">uv run：在项目环境中运行命令。</span><br></pre></td></tr></table></figure><p><strong>创建虚拟环境（替代 <code>venv</code> 和 <code>virtualenv</code>）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv venv：创建一个新的虚拟环境。</span><br></pre></td></tr></table></figure><p><strong>查看使用环境的文档</strong></p><p>管理环境中的包（替代 <code>pip</code> 和 <code>pipdeptree</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uv pip install：安装包到当前环境。</span><br><span class="line">uv pip show：显示已安装包的详细信息。</span><br><span class="line">uv pip freeze：列出已安装包及其版本。</span><br><span class="line">uv pip check：检查当前环境中的包是否兼容。</span><br><span class="line">uv pip list：列出已安装的包。</span><br><span class="line">uv pip uninstall：卸载包。</span><br><span class="line">uv pip tree：查看环境的依赖树。</span><br></pre></td></tr></table></figure><p><strong>实用工具</strong></p><p>管理和查看 <code>uv</code> 的状态，如缓存、存储目录，或执行自更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uv cache clean：清理缓存条目。</span><br><span class="line">uv cache prune：清理过期的缓存条目。</span><br><span class="line">uv cache dir：显示 uv 缓存目录路径。</span><br><span class="line">uv tool dir：显示 uv 工具目录路径。</span><br><span class="line">uv python dir：显示 uv 安装的 Python 版本路径。</span><br><span class="line">uv self update：将 uv 更新到最新版本。</span><br></pre></td></tr></table></figure><h4 id="详细教程"><a href="#详细教程" class="headerlink" title="详细教程"></a>详细教程</h4><p><strong>1. 安装 <code>uv</code></strong></p><p>你可以通过多种方式安装 <code>uv</code>：</p><ul><li><p><strong>使用 curl (macOS, Linux):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 pip (需要先有 Python 和 pip):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uv</span><br></pre></td></tr></table></figure><p><strong>使用 Homebrew (macOS):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install uv</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Scoop (Windows):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install uv</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Winget (Windows):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winget install astral.uv</span><br></pre></td></tr></table></figure></li></ul><p>安装完成后，可以通过运行以下命令来验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv --version</span><br></pre></td></tr></table></figure><p><strong>2. 创建和管理虚拟环境</strong></p><p><code>uv</code> 使用 <code>uv venv</code> 命令来创建虚拟环境，这类似于 Python 内置的 <code>venv</code> 模块。</p><ul><li><p><strong>创建虚拟环境:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 .venv 的虚拟环境 (这是常见的命名约定)</span></span><br><span class="line">uv venv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以指定环境名称</span></span><br><span class="line">uv venv my_env_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以指定 Python 解释器版本 (如果系统中有多个)</span></span><br><span class="line">uv venv -p 3.11 <span class="comment"># 使用 Python 3.11</span></span><br></pre></td></tr></table></figure><p>这会在当前目录下创建一个 <code>.venv</code> (或你指定的名字) 的文件夹。</p></li><li><p><strong>激活虚拟环境:</strong><br>创建环境后，你需要激活它才能使用。激活方式与 <code>venv</code> 相同：</p><ul><li><strong>macOS &#x2F; Linux (bash&#x2F;zsh):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br></pre></td></tr></table></figure></li><li><strong>Windows (cmd.exe):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.venv\Scripts\activate.bat</span><br></pre></td></tr></table></figure></li><li><strong>Windows (PowerShell):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.venv\Scripts\Activate.ps1</span><br></pre></td></tr></table></figure>激活后，你的命令行提示符通常会显示环境名称（例如 <code>(.venv)</code>）。</li></ul></li><li><p><strong>退出虚拟环境:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. 安装 Python 包</strong></p><p><code>uv</code> 使用 <code>uv pip install</code> 命令来安装包，用法与 <code>pip install</code> 非常相似。请确保你已经<strong>激活了虚拟环境</strong>。</p><ul><li><p><strong>安装单个包:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装最新版本的 requests 包</span></span><br><span class="line">uv pip install requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装特定版本的 requests 包</span></span><br><span class="line">uv pip install requests==2.28.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装最低版本要求</span></span><br><span class="line">uv pip install requests&gt;=2.20</span><br></pre></td></tr></table></figure></li><li><p><strong>安装多个包:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv pip install requests flask Django</span><br></pre></td></tr></table></figure></li><li><p><strong>从 <code>requirements.txt</code> 文件安装:</strong><br>这是管理项目依赖的常用方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设你有一个 requirements.txt 文件</span></span><br><span class="line"><span class="comment"># 内容类似:</span></span><br><span class="line"><span class="comment"># requests==2.28.1</span></span><br><span class="line"><span class="comment"># flask&gt;=2.0</span></span><br><span class="line"></span><br><span class="line">uv pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><code>uv</code> 会读取文件并安装所有指定的包及其依赖。</p></li><li><p><strong>安装带 “extras” 的包:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv pip install <span class="string">&quot;package[extra1,extra2]&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安装开发依赖:</strong><br>通常将开发依赖放在不同的文件（如 <code>requirements-dev.txt</code>）中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv pip install -r requirements-dev.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>4. 同步环境 (<code>uv pip sync</code>)</strong></p><p><code>uv pip sync</code> 是一个非常有用的命令，它能确保你的虚拟环境<strong>精确匹配</strong> <code>requirements.txt</code> 文件中的内容。</p><ul><li>它会安装 <code>requirements.txt</code> 中列出的所有包。</li><li>它会<strong>卸载</strong>虚拟环境中<strong>已安装但未在</strong> <code>requirements.txt</code> 中列出的包。</li></ul><p>这对于保持环境干净、可复现非常重要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保环境与 requirements.txt 完全一致</span></span><br><span class="line">uv pip <span class="built_in">sync</span> requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有开发依赖，可以同时同步多个文件</span></span><br><span class="line">uv pip <span class="built_in">sync</span> requirements.txt requirements-dev.txt</span><br></pre></td></tr></table></figure><p><strong>对比:</strong> <code>uv pip install -r requirements.txt</code> 只会安装或更新包，不会删除多余的包，而 <code>uv pip sync</code> 会严格同步。</p><p><strong>5. 查看已安装的包</strong></p><ul><li><p><strong>列出已安装的包 (简单列表):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv pip list</span><br></pre></td></tr></table></figure></li><li><p><strong>冻结依赖 (生成 <code>requirements.txt</code> 格式):</strong><br>这个命令会输出当前环境中所有已安装的包及其精确版本，非常适合用来生成 <code>requirements.txt</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>6. 卸载包</strong></p><ul><li><p><strong>卸载单个或多个包:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv pip uninstall requests flask</span><br></pre></td></tr></table></figure></li><li><p><strong>从 <code>requirements.txt</code> 卸载:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv pip uninstall -r requirements.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>7. 生成依赖锁定文件 (<code>pip-compile</code> 的替代)</strong></p><p><code>uv</code> 也提供了类似 <code>pip-tools</code> 中 <code>pip-compile</code> 的功能，用于生成固定的依赖版本文件。这通常用于更严格的依赖管理，确保每次安装都使用完全相同的版本。</p><ul><li><p><strong>从 <code>pyproject.toml</code> 或 <code>requirements.in</code> 生成 <code>requirements.txt</code>:</strong><br>假设你的 <code>pyproject.toml</code> 文件中有如下依赖定义：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[project]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;my-package&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">dependencies</span> = [</span><br><span class="line">  <span class="string">&quot;flask&gt;=2.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;requests&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="section">[project.optional-dependencies]</span></span><br><span class="line"><span class="attr">dev</span> = [</span><br><span class="line">  <span class="string">&quot;pytest&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>或者你有一个 <code>requirements.in</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask&gt;=2.0</span><br><span class="line">requests</span><br></pre></td></tr></table></figure><p>你可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 pyproject.toml 生成 requirements.txt (默认)</span></span><br><span class="line">uv pip compile pyproject.toml -o requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者从 requirements.in 生成</span></span><br><span class="line">uv pip compile requirements.in -o requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成开发依赖的锁定文件</span></span><br><span class="line">uv pip compile pyproject.toml --extra dev -o requirements-dev.txt</span><br></pre></td></tr></table></figure><p>这会解析所有子依赖，并生成一个包含所有包精确版本的 <code>requirements.txt</code> (或 <code>-dev.txt</code>) 文件。然后你可以使用 <code>uv pip sync</code> 来安装这些锁定的依赖。</p></li></ul><p><strong>8. 在虚拟环境中运行命令 (<code>uv run</code>)</strong></p><p>如果你不想激活虚拟环境，但想在其中执行某个命令（比如运行你的 Python 脚本），可以使用 <code>uv run</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设你在项目根目录，并且 .venv 存在</span></span><br><span class="line"><span class="comment"># 运行你的 main.py 脚本</span></span><br><span class="line">uv run python main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 pytest 测试</span></span><br><span class="line">uv run pytest</span><br></pre></td></tr></table></figure><p><code>uv run</code> 会自动检测 <code>.venv</code> 目录，并在该环境中执行后续命令。</p><p><strong>总结：为什么使用 <code>uv</code>？</strong></p><ul><li><strong>速度:</strong> 最显著的优势，能大幅节省安装和管理依赖的时间。</li><li><strong>简洁:</strong> 将多个工具（<code>pip</code>, <code>venv</code>, <code>pip-tools</code>）的功能整合到一个命令行工具中。</li><li><strong>现代:</strong> 采用更现代、高效的技术栈（Rust, PubGrub）。</li><li><strong>易用性:</strong> 旨在提供比 <code>pip</code> 更友好的错误提示和用户体验。</li><li><strong>兼容性:</strong> <code>uv pip</code> 命令与 <code>pip</code> 高度兼容，迁移成本低。</li></ul><p><code>uv</code> 是一个非常有前途的工具，特别适合那些对性能有要求或者希望简化 Python 环境和依赖管理流程的开发者。虽然它还在快速发展中，但已经足够稳定，可以在许多项目中使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> uv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css选择器</title>
      <link href="/2024/07/15/Css%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2024/07/15/Css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table><thead><tr><th align="center">基本选择器</th><th align="center">特点</th><th align="center">用法</th></tr></thead><tbody><tr><td align="center">通配选择器</td><td align="center">选中所有标签，一般用于清除样式</td><td align="center">* {color:red}</td></tr><tr><td align="center">元素选择器</td><td align="center">选中所有同种标签，但是不能差异化选择</td><td align="center">h1 {color:red}</td></tr><tr><td align="center">类选择器</td><td align="center">选中所有特定类名（<font color="red">class</font>值）的元素-一使用频率很高。</td><td align="center">.say {color:red}</td></tr><tr><td align="center">ID选择器</td><td align="center">选中特定<font color="red">id</font>值的那个元素（唯一的）</td><td align="center">#earth {color:red}</td></tr><tr><td align="center">交集选择器</td><td align="center">最常用：元素+类名 (<font color="red">贴在一起写</font>)</td><td align="center">p.beauty {color:red}</td></tr><tr><td align="center">并集选择器</td><td align="center"><font color="red">逗号隔开</font></td><td align="center">#peiqi,.rich,.beauty {color:red}</td></tr><tr><td align="center">后代选择器</td><td align="center">选择的是所有的后代 <font color="red">空格隔开</font></td><td align="center">ul li a {color:red}</td></tr><tr><td align="center">子代选择器</td><td align="center">选择的是子代 <font color="red">中间是&gt;</font></td><td align="center">div&gt;p&gt;a {color:red}</td></tr><tr><td align="center">兄弟选择器</td><td align="center">相邻：选中元素后面兄弟元素  <font color="red">中间是+</font><br>通用：选中元素后面所有的兄弟元素 <font color="red">中间是~</font></td><td align="center">div+p {color:red}<br>div~p {color:red}</td></tr><tr><td align="center">属性选择器</td><td align="center">选中具有某符合要求属性的元素 有5种<br><font color="red">^</font> 以xx开头<br><font color="red">$</font> 以xx开头<br><font color="red">*</font> 包含xx的</td><td align="center">[title] <br>[title&#x3D;“color”]<br> [title^&#x3D;“co”]<br>[title$&#x3D;“or”]  <br>[title*&#x3D;“ol”]</td></tr></tbody></table><h3 id="伪类选择器：选中特殊状态的元素"><a href="#伪类选择器：选中特殊状态的元素" class="headerlink" title="伪类选择器：选中特殊状态的元素"></a>伪类选择器：选中特殊状态的元素</h3><ul><li><h4 id="动态伪类-LVHA原则"><a href="#动态伪类-LVHA原则" class="headerlink" title="动态伪类 LVHA原则"></a>动态伪类 <font color="red">LVHA原则</font></h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a:link&#123;&#125;  /*选中的是没有访问过的a元素*/</span><br><span class="line">a:visited&#123;&#125;  /*选中的是访问过的a元素*/</span><br><span class="line">a:hover&#123;&#125;  /*选中的是鼠标悬浮状态的a元素*/</span><br><span class="line">a:active&#123;&#125; /*选中的是激活状态的a元素*/</span><br><span class="line">span:hover&#123;&#125;  /*选中的是鼠标悬浮状态的span元素*/</span><br><span class="line">span:active&#123;&#125; /*选中的是激活状态的span元素*/</span><br><span class="line">input:focus&#123;&#125; /*获取焦点元素，当用户：点击元素选择元素时，就是获得焦点。表单类才能用*/</span><br></pre></td></tr></table></figure><ul><li><h4 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">div&gt;p:first-child &#123;&#125; /*选中的是div的第一个儿子p元素*/</span><br><span class="line">div p:first-child&#123;&#125; /*选中的是div的后代p元素，且p的父亲是谁无所谓，但p必须是其父亲的第一个儿子*/</span><br><span class="line">p:first-child&#123;&#125; /*选中的是p元素，且p的父亲是谁无所谓，但p必须是其父亲的第一个儿子*/</span><br><span class="line">div&gt;p:last-child&#123;&#125; /*最后一个儿子*/</span><br><span class="line">div&gt;p:nth-child(2)&#123;&#125; /*为第2个儿子 取值0~999...*/</span><br><span class="line">div&gt;p:nth-child(2n)&#123;&#125; /*选中偶数 n为0 1 2 ...*/</span><br><span class="line">div&gt;p:nth-child(-n+5)&#123;&#125; /*前5个 ()遵循an+b*/</span><br><span class="line">div&gt;p:first-of-type&#123;&#125; /*选中的是div的第一个儿子p元素（按照所有同类型兄弟计算的）*/</span><br><span class="line">div&gt;p:last-of-type&#123;&#125; /*选中的是div的最后一个儿子p元素（按照所有同类型兄弟计算的）*/</span><br><span class="line">div&gt;p:nth-of-type(5)&#123;&#125; /*选中的是div的第n个儿子p元素（按照所有同类型兄弟计算的）*/</span><br><span class="line">div&gt;p:nth-last-child(5)&#123;&#125; /*倒数*/</span><br><span class="line">div&gt;p:nth-last-of-type(5)&#123;&#125; /*倒数*/</span><br><span class="line">div&gt;p:only-child /*选择没有兄弟的元素(独生子女)*/</span><br><span class="line">div&gt;p:only-of-type /*选择没有同类型兄弟的元素*/</span><br></pre></td></tr></table></figure><blockquote><p><strong>关于n的值：</strong></p><ul><li>0或不写：什么都选不中一几乎不用。</li><li>n：选中所有子元素一几乎不用。</li><li>1～正无穷的整数，选中对应序号的子元素。</li><li>2n或even：选中序号为偶数的子元素。</li><li>2n+1或odd：选中序号为奇数的子元素。</li><li>-n+3：选中前三个。</li></ul></blockquote><ul><li><h4 id="否定伪类"><a href="#否定伪类" class="headerlink" title="否定伪类"></a>否定伪类</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&gt;p:not（选择器）排除满足括号中条件的元素</span><br><span class="line">div&gt;p:not(.fail) &#123;&#125; /*选中的是div的儿子p元素，但是排除类名为fail的元素*/</span><br><span class="line">div&gt;p:not([title^=&quot;你要加油&quot;]）&#123;&#125; /*选中的是div的儿子p元素，但是排除title属性值以“你要加油&quot;开头的*/</span><br><span class="line">div&gt;p:not(:first-child) &#123;&#125; /*选中的是div的儿子p元素，但排除第一个儿子p元素*/</span><br></pre></td></tr></table></figure><ul><li><h4 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input:checked &#123;&#125; /*选中的是勾选的复选框或单选按钮  对颜色不生效*/</span><br><span class="line">input:disabled &#123;&#125; /*选中的是被禁用的input元素*/</span><br><span class="line">input:enabled &#123;&#125;  /*选中的是可用的input元素*/</span><br></pre></td></tr></table></figure><ul><li><h4 id="目标伪类（了解）"><a href="#目标伪类（了解）" class="headerlink" title="目标伪类（了解）"></a>目标伪类（了解）</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:target&#123;&#125; 选中锚点指向的元素</span><br></pre></td></tr></table></figure><ul><li><h4 id="语言伪类（了解）"><a href="#语言伪类（了解）" class="headerlink" title="语言伪类（了解）"></a>语言伪类（了解）</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:lang()&#123;&#125;根据指定的语言选择元素（本质是看lang属性的值）</span><br></pre></td></tr></table></figure><ul><li><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div::first-letter &#123;&#125; /*选中的是div中的第一个文字*/</span><br><span class="line">div::first-line &#123;&#125; /*选中的是div中的第一行文字*/</span><br><span class="line">div::selection &#123;background-color:green;color:orange;&#125; /*选中的是div中被鼠标选择的文字*/</span><br><span class="line">input::placeholder &#123;color:red&#125; /*选中的是input元素中的提示文字*/</span><br><span class="line">p::before &#123;content: &quot;￥&quot;&#125; /*选中的是p元素最开始的位置，随后创建一个子元素*/</span><br><span class="line">p::after &#123;content: &quot;.00&quot;&#125; /*选中的是p元素最后的位置，随后创建一个子元素*/</span><br></pre></td></tr></table></figure><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><blockquote><p><strong>总结：</strong>行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器&gt;通配选择器。</p></blockquote><p><strong>选择器权重计算：</strong></p><blockquote><p>格式：（a，b，c）<br>a：ID选择器的个数<br>b：类、伪类、属性选择器的个数<br>c：元素、优伪元素选择器的个数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1  .container span.slogan&#123;&#125;  (0,2,1)</span><br><span class="line">2  div&gt;p&gt;span:nth-child(1)&#123;&#125;  (0,1,3)</span><br><span class="line">按顺序比较，所以1&gt;2，1的优先级高，如果权重一样就是后来者优先级高</span><br><span class="line"></span><br><span class="line">.container&#123;color:red !important&#125; </span><br><span class="line">属性加上!important会有最高的优先级</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次使用rclone同步文件</title>
      <link href="/2024/01/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8rclone%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6/"/>
      <url>/2024/01/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8rclone%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-rclone"><a href="#什么是-rclone" class="headerlink" title="什么是 rclone"></a>什么是 <code>rclone</code></h1><p><code>rclone</code> 是一个命令行程序，用于管理云存储上的文件。它是云供应商的网络存储接口的一个功能丰富的替代品。超过 40 种云存储产品支持 <code>rclone</code>，包括 S3 对象存储、企业和消费者文件存储服务以及标准传输协议。</p><p>用户称 <code>rclone</code> 为“云存储的瑞士军刀”、 “无异于魔法的科技”。<br>rclone 具有强大的云等同于 unix 命令 rsync、cp、mv、mount、ls、ncdu、tree、rm 和 cat。rclone 熟悉的语法包括 shell 管道支持和–dry-run 保护。它在命令行、脚本或通过其 API 使用。</p><p><code>rclone</code> 多种文件传输协议，支持 SFTP，HTTP，WebDAV，FTP 和 DLNA。rclone 是一个成熟的开源软件，最初受 rsync 的启发并采用 Golang 编写。其文档和社区也都非常好，提供广泛和友好的使用用例。</p><p><a href="https://rclone.org/">rclone 官网</a></p><h1 id="rclone-功能"><a href="#rclone-功能" class="headerlink" title="rclone 功能"></a>rclone 功能</h1><p>rclone 支持但不仅限于下面列出功能：</p><ul><li>将文件备份（和加密）到云存储</li><li>从云存储恢复（和解密）文件</li><li>将云数据镜像到其他云服务或本地</li><li>将数据迁移到云端，或在云存储供应商之间迁移</li><li>将多个、加密、缓存或多样化的云存储挂载为磁盘</li><li>使用 lsf、ljson、size、ncdu 分析和说明云存储上保存的数据</li><li>联合文件系统一起呈现多个本地和&#x2F;或云文件系统作为一个</li></ul><p>但一般用的最多的功能就是备份文件，同步文件。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>接送服务<ul><li>始终检查 MD5、SHA1 哈希值以确保文件完整性</li><li>时间戳保留在文件中</li><li>可以随时重新启动操作</li><li>可以进出网络，例如两个不同的云提供商</li><li>可以使用多线程下载到本地磁盘</li></ul></li><li>将新文件或更改的文件复制到云存储</li><li>同步（一种方式）使目录相同</li><li>验证后将文件移动到云存储删除本地</li><li>检查哈希和丢失&#x2F;额外的文件</li><li>将您的云存储挂载为网络磁盘</li><li>通过 HTTP &#x2F; WebDav &#x2F; FTP &#x2F; SFTP &#x2F; DLNA 服务本地或远程文件</li><li>实验性基于 Web 的 GUI</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>rclone</code> 就是一个二进制文件包，可以直接下载设置环境变量即可使用，这里直接使用官方的脚本安装,本次的安装环境为 <strong>Ubuntu23.10</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip</span><br><span class="line">unzip rclone-current-linux-amd64.zip</span><br><span class="line">cd rclone-*-linux-amd64</span><br><span class="line"></span><br><span class="line">sudo cp rclone /usr/bin/</span><br><span class="line">sudo chown root:root /usr/bin/rclone</span><br><span class="line">sudo chmod 755 /usr/bin/rclone</span><br></pre></td></tr></table></figure><p>安装之后可以用 <code>rclone version</code> 来查看版本号。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置可以直接添加配置文件的方式或者通过进入交互式配置会话命令一步步的完成配置。<br>默认配置完成的后配置文件都保存在：<code>/root/.config/rclone/rclone.conf</code> 目录下。</p><p>比如使用腾讯 COS 作为存储，可以直接编辑文件 <code>/root/.config/rclone/rclone.conf</code><br>配置文件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[tencent-cos] # 自定义的名称</span><br><span class="line">type = s3  # 存储类型，参考官方文档所有支持的类型</span><br><span class="line">provider = TencentCOS  # 提供商，参考官方文档或者全部</span><br><span class="line">env_auth = false   # 不通过环境变量配置认证</span><br><span class="line">access_key_id = AKxxxxxxxx  # 腾讯云后台生成的密钥key</span><br><span class="line">secret_access_key = Secretxxxxxxx # 腾讯云后台生成的密钥secret</span><br><span class="line">endpoint = cos.ap-chengdu.myqcloud.com # 腾讯云cos所在的地区，看你所在存储桶的公网地址</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 本地到网盘</span><br><span class="line">rclone [功能选项] &lt;本地路径&gt; &lt;配置名称:路径&gt; [参数] [参数]</span><br><span class="line"># 网盘到本地</span><br><span class="line">rclone [功能选项] &lt;配置名称:路径&gt; &lt;本地路径&gt; [参数] [参数]</span><br><span class="line"># 网盘到网盘</span><br><span class="line">rclone [功能选项] &lt;配置名称:路径&gt; &lt;配置名称:路径&gt; [参数] [参数]</span><br><span class="line"></span><br><span class="line"># [参数]为可选项</span><br></pre></td></tr></table></figure><p>以下是一些示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 同步本地/data/file的文件夹内容到tencent-cos存储下的/beifen文件夹中,并且排除/root/excludes.txt中指定的文件内容</span><br><span class="line">rclone sync /data/file tencent-cos:/beifen --exclude-from &#x27;/root/excludes.txt&#x27;</span><br><span class="line"></span><br><span class="line"># 两个网盘文件同步</span><br><span class="line">rclone sync 配置网盘名称1:网盘路径 配置网盘名称2:网盘路径</span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>可以使用 <code>rclone --help</code> 查看</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>rclone copy</td><td>复制</td></tr><tr><td>rclone move</td><td>移动，如果要在移动后删除空源目录，加上 <code>--delete-empty-src-dirs</code> 参数</td></tr><tr><td>rclone mount</td><td>挂载</td></tr><tr><td>rclone sync</td><td>同步：将源目录同步到目标目录，只更改目标目录</td></tr><tr><td>rclone size</td><td>查看网盘文件占用大小</td></tr><tr><td>rclone delete</td><td>删除路径下的文件内容</td></tr><tr><td>rclone purge</td><td>删除路径及其所有文件内容</td></tr><tr><td>rclone mkdir</td><td>创建目录</td></tr><tr><td>rclone rmdir</td><td>删除目录</td></tr><tr><td>rclone rmdirs</td><td>删除指定环境下的空目录。如果加上 <code>--leave-root</code> 参数，则不会删除根目录</td></tr><tr><td>rclone check</td><td>检查源和目的地址数据是否匹配</td></tr><tr><td>rclone ls</td><td>列出指定路径下的所有的文件以及文件大小和路径</td></tr><tr><td>rclone lsl</td><td>比上面多一个显示上传时间</td></tr><tr><td>rclone lsd</td><td>列出指定路径下的目录</td></tr><tr><td>rclone lsf</td><td>列出指定路径下的目录和文件</td></tr></tbody></table><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>-n &#x3D; –dry-run</td><td>测试运行，查看 <code>rclone</code> 在实际运行中会进行哪些操作</td></tr><tr><td>-P &#x3D; –progress</td><td>显示实时传输进度，500 ms 刷新一次，否则默认 <code>1</code> 分钟刷新一次</td></tr><tr><td>–cache-chunk-size 5M</td><td>块的大小，默认 <code>5M</code> 越大上传越快，占用内存越多，太大可能会导致进程中断</td></tr><tr><td>–onedrive-chunk-size 100M</td><td>提高 OneDrive 上传速度适用于 G 口宽带服务器</td></tr><tr><td>–drive-chunk-size 64M</td><td>提高 Google Drive 上传速度适用于 G 口宽带服务器</td></tr><tr><td>–cache-chunk-total-size SizeSuffix</td><td>块可以在本地磁盘上占用的总大小</td></tr><tr><td>–transfers&#x3D;N</td><td>并行文件数，默认为 <code>4</code>。在比较小的内存的 VPS 上建议调小这个参数，比如 128M 的小鸡上使用建议设置为 <code>1</code>。</td></tr><tr><td>–config string</td><td>指定配置文件路径，string 为配置文件路径</td></tr><tr><td>–ignore-errors</td><td>跳过错误</td></tr><tr><td>–size-only</td><td>根据文件大小校验，不校验 hash</td></tr><tr><td>–drive-server-side-across-configs</td><td>服务端对服务端传输</td></tr></tbody></table><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>rclone_CONFIG</td><td>自定义配置文件路径</td></tr><tr><td>rclone_CONFIG_PASS</td><td>若 rclone 进行了加密设置，把此环境变量设置为密码，可自动解密配置文件</td></tr><tr><td>rclone_RETRIES</td><td>上传失败重试次数，默认 <code>3</code> 次</td></tr><tr><td>rclone_RETRIES_SLEEP</td><td>上传失败重试等待时间，默认禁用，单位 s、m、h 分别代表秒、分钟、小时</td></tr><tr><td>CLONE_TRANSFERS</td><td>并行上传文件数</td></tr><tr><td>rclone_CACHE_CHUNK_SIZE</td><td>块的大小</td></tr><tr><td>rclone_CACHE_CHUNK_TOTAL_SIZE</td><td>块可以在本地磁盘上占用的总大小</td></tr><tr><td>rclone_IGNORE_ERRORS&#x3D;true</td><td>跳过错误</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> linux </tag>
            
            <tag> rclone </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows装机</title>
      <link href="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h1><p><strong>此教程为纯净版镜像，不包含任何广告，第三方软件，捆绑后门。</strong></p><blockquote><p>准备：</p><blockquote><p>空 U 盘*1（会清空 U 盘的数据，如果有数据请提前备份）<br>最好是 USB3.0 接口的，容量可以大点，8G 起步，做完启动盘可以存东西，比如镜像等。</p></blockquote></blockquote><h1 id="1-镜像"><a href="#1-镜像" class="headerlink" title="1.镜像"></a>1.镜像</h1><ul><li><strong>windows11</strong><br>可以在 win11 官网下载 <a href="https://www.microsoft.com/zh-cn/software-download/windows11">Download Windows 11</a><br><img src="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/%E5%9B%BE%E7%89%871.png"></li><li><strong>windows10</strong><br>可以去 msdn 下载 <a href="https://next.itellyou.cn/">MSDN 原版软件</a><br><img src="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/%E5%9B%BE%E7%89%872.jpg"></li></ul><p>下载镜像可以用<a href="https://www.freedownloadmanager.org/zh/">FDM 下载器</a></p><h1 id="2-启动-U-盘的制作"><a href="#2-启动-U-盘的制作" class="headerlink" title="2.启动 U 盘的制作"></a>2.启动 U 盘的制作</h1><blockquote><p><strong>！！！注意，此操作会清空 U 盘数据！！！<br>！！！注意，此操作会清空 U 盘数据！！！<br>！！！注意，此操作会清空 U 盘数据！！！</strong></p></blockquote><p>常用的制作 PE 的工具有两个，任选其一即可</p><ul><li><p>一般使用<a href="https://upe.net/">优启通</a>（推荐）<br><img src="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/%E5%9B%BE%E7%89%873.png"><br>默认即可</p></li><li><p>或者使用<a href="https://wepe.com.cn/">微 pe</a><br><img src="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/%E5%9B%BE%E7%89%874.png"><br>默认即可</p></li></ul><h1 id="3-操作系统安装"><a href="#3-操作系统安装" class="headerlink" title="3. 操作系统安装"></a>3. 操作系统安装</h1><blockquote><p><strong>注意，装机会清空 C 盘所有数据</strong><br><strong>注意，装机会清空 C 盘所有数据</strong><br><strong>注意，装机会清空 C 盘所有数据</strong></p></blockquote><p>将上面下载的镜像复制到 <code>U盘</code> 或除 <code>C盘</code> 的其他硬盘（ <code>C盘</code> 数据会被清空，所以不能放 <code>C盘</code> ）<br>这时需要找主板的快速启动按键，可以在网上找，我这台电脑是 <code>F9</code><br>把电脑关机 插上 U 盘 开机连续按 F9 选择 U 盘 按 enter<br>之后等待进入 PE 等待程序加载完成</p><ol><li>硬盘分区<br>首先打开 Diskgenius<br><img src="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/%E5%9B%BE%E7%89%875.png"><br><strong>删除分区：</strong><br>在硬盘上右键，此操作会将硬盘的所有分区删除。之后点击左上角保持更改。<br><img src="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/%E5%9B%BE%E7%89%876.png"><br>如果想删除单个分区，可以在分区上右键，进行删除。<br>新建分区：<a href="https://zhuanlan.zhihu.com/p/560753564">UEFI 启动</a>， <code>UEFI</code> 模式新电脑一般都支持<br>首先将分区改成 GPT（GUID）格式（硬盘右键）<br><img src="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/%E5%9B%BE%E7%89%877.png"><br>如果是要做系统（即对系统盘操作）<br>在刚清空的硬盘（或分区）右键，首先建立一个<code>ESP</code>分区（UEFI 引导要用到），之后建立新分区默认即可(最好记下容量大小，方便后面装系统定位分区用)，之后点击左上角保存更改。</li><li>安装系统<br>方法 1：（最简单，任何 pe 都支持，可能部分主板无法通过这个方法装 win11）<br>从 U 盘（硬盘）找到下载的镜像，直接双击，点击里面一个 <code>setup.exe</code> ，之后就会进入安装界面，先选择没有激活秘钥，选择系统（如果是个人的笔记本，系统可以选家庭版，这样可以自动激活，而且是正版的，如果是台式机，主板不带激活，可以选专业版，之后激活）。之后，选好系统安装位置（可根据硬盘容量确定位置），如果顺利就等待安装完重启即可。最好重启的时候拔掉 U 盘。<br>方法 2：<br>如果用的 U 启通：<br>可以用 <code>EIX</code> 系统安装软件，选好镜像和位置即可。<br><img src="/2023/12/25/Windows%E8%A3%85%E6%9C%BA%E6%95%99%E7%A8%8B/%E5%9B%BE%E7%89%878.jpg"><br>如果顺利就等待安装完重启即可。最好重启的时候拔掉 U 盘。</li></ol><h1 id="4-启动-Windows"><a href="#4-启动-Windows" class="headerlink" title="4. 启动 Windows"></a>4. 启动 Windows</h1><p>重启后如果顺利，就进入了系统：</p><ul><li><p>Windows11<br>跳联网激活：<br>按<kbd>Shift</kbd>+<kbd>F10</kbd>，有个窗口会打开,点击一下窗口，在里面输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oobe\BypassNRO.cmd</span><br></pre></td></tr></table></figure><p>回车执行命令之后，此时 Win11 就会自动重启，重启之后联网界面就会有一个暂时跳过的选项，可以和以前一样离线配置，记住用户名最好为英文或数字的组合（如果是中文，在以后的使用中部分软件会报错，很麻烦），密码为空就是无密码。</p></li><li><p>Windows10<br>直接跳过联网即可，用户名设英文数字，密码为空就是无密码。</p></li></ul><h1 id="5-驱动安装："><a href="#5-驱动安装：" class="headerlink" title="5. 驱动安装："></a>5. 驱动安装：</h1><p>只装一个显卡驱动即可，其他驱动 windows 会自动联网下载安装。</p><p><strong>英伟达显卡驱动：</strong><br>可以直接去<a href="https://www.nvidia.cn/software/nvidia-app/">英伟达官网</a>下载 <code>NVIDIA App</code> 来一键安装<br>也可以去 <a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">英伟达驱动下载</a> 手动搜索自己机器的显卡驱动,显卡的型号可以用<a href="https://www.techpowerup.com/gpuz/">GPU-Z</a>查看<br><strong>激活 windows，可以用 <a href="https://www.baidu.com/s?wd=HEU_KMS_Activator">HEU_KMS_Activator</a> ,百度上能搜到</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu调整Swap分区大小</title>
      <link href="/2023/12/01/Ubuntu%E8%B0%83%E6%95%B4SWAP%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
      <url>/2023/12/01/Ubuntu%E8%B0%83%E6%95%B4SWAP%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-Swap-分区"><a href="#Ubuntu-Swap-分区" class="headerlink" title="Ubuntu Swap 分区"></a>Ubuntu Swap 分区</h1><p>Swap 分区指的就是 linux 的交换分区<br>Swap 分区在系统的物理内存不够用的时候，把硬盘内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到 Swap 分区中，等到那些程序要运行时，再从 Swap 分区中恢复保存的数据到内存中。<br>Ubuntu 安装后，默认的 Swap 分区容量是 2GB，在编译代码时存在交换分区容量不足，导致编译失败的情况，下面展示了调整 Swap 分区大小到 8G 的过程。</p><h1 id="调整-Swap-分区大小"><a href="#调整-Swap-分区大小" class="headerlink" title="调整 Swap 分区大小"></a>调整 Swap 分区大小</h1><h2 id="1-首先用-ssh-连接上-Ubuntu-服务器"><a href="#1-首先用-ssh-连接上-Ubuntu-服务器" class="headerlink" title="1.首先用 ssh 连接上 Ubuntu 服务器"></a>1.首先用 ssh 连接上 Ubuntu 服务器</h2><p>查看内存分区大小可以用 <code>free -m</code> 或 <code>free -h</code> 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@zhao:~# free -h</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.8Gi       690Mi       2.7Gi       1.6Mi       640Mi       3.1Gi</span><br><span class="line">Swap:          3.8Gi          0B       3.8Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以看到 Swap 分区大小为 3.8G</p><h2 id="2-关闭-Swap-分区"><a href="#2-关闭-Swap-分区" class="headerlink" title="2.关闭 Swap 分区"></a>2.关闭 Swap 分区</h2><p>先查找 <code>Swap文件</code> 的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@zhao:~# swapon --show</span><br><span class="line">NAME      TYPE SIZE USED PRIO</span><br><span class="line">/swap.img file 3.8G   0B   -2</span><br></pre></td></tr></table></figure><p>可见位置在根目录下，这时我们关闭 Swap 分区，然后再看内存分区大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@zhao:~# swapoff /swap.img</span><br><span class="line"></span><br><span class="line">root@zhao:~# free -h</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.8Gi       680Mi       2.7Gi       1.6Mi       641Mi       3.1Gi</span><br><span class="line">Swap:             0B          0B          0B</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-调整-swap-img-到-8GB，并格式化"><a href="#3-调整-swap-img-到-8GB，并格式化" class="headerlink" title="3.调整&#x2F;swap.img 到 8GB，并格式化"></a>3.调整&#x2F;swap.img 到 8GB，并格式化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@zhao:~# fallocate -l 8G /swap.img</span><br><span class="line"></span><br><span class="line">root@zhao:~# chmod 600 /swap.img</span><br><span class="line"></span><br><span class="line">root@zhao:~# mkswap /swap.img</span><br><span class="line">mkswap: /swap.img: warning: wiping old swap signature.</span><br><span class="line">Setting up swapspace version 1, size = 8 GiB (8589930496 bytes)</span><br><span class="line">no label, UUID=535c80d4-c681-4067-b254-dcac37e84b51</span><br></pre></td></tr></table></figure><h2 id="4-启用-Swap-分区，再查看内存分区大小"><a href="#4-启用-Swap-分区，再查看内存分区大小" class="headerlink" title="4.启用 Swap 分区，再查看内存分区大小"></a>4.启用 Swap 分区，再查看内存分区大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@zhao:~# swapon /swap.img</span><br><span class="line"></span><br><span class="line">root@zhao:~# free -h</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.8Gi       686Mi       2.7Gi       1.6Mi       644Mi       3.1Gi</span><br><span class="line">Swap:          8.0Gi          0B       8.0Gi</span><br></pre></td></tr></table></figure><p>此时，Swap 已经成功更改为 8G</p><h2 id="5-持久化（如果重启后丢失更改）-可选"><a href="#5-持久化（如果重启后丢失更改）-可选" class="headerlink" title="5.持久化（如果重启后丢失更改）(可选)"></a>5.持久化（如果重启后丢失更改）(可选)</h2><p>你可以通过将新创建的交换文件添加到 <code>/etc/fstab</code> 文件来使更改持久化。<br>注意：对 <code>/etc/fstab</code> 文件进行任何更改之前，最好先进行备份。</p><pre><code>root@zhao:~# cp /etc/fstab /etc/fstab.bak</code></pre><p>首先先打开 <code>/etc/fstab</code> 文件，这里可以用 <code>vim</code> 来操作</p><pre><code>root@zhao:~# vim /etc/fstab</code></pre><p>将 <code>/swap.img none swap sw 0 0</code> 添加到 <code>/etc/fstab</code> 文件的末尾<br>当然也可以用以下命令一键添加</p><pre><code>echo &#39;/swap.img none swap sw 0 0&#39; | sudo tee -a /etc/fstab</code></pre><p>现在一切都准备好了。即使在重新启动你的 Linux 系统后，你的交换文件也会被使用。</p><h2 id="6-调整-swappiness-参数-可选"><a href="#6-调整-swappiness-参数-可选" class="headerlink" title="6.调整 swappiness 参数(可选)"></a>6.调整 swappiness 参数(可选)</h2><p>swappiness 参数决定了交换空间的使用频率。swappiness 值的范围从 0 到 100。较高的值意味着交换空间将被更频繁地使用。Ubuntu 系统默认的 swappiness 是 60。<br>你可以使用以下命令检查 swappiness 的值</p><pre><code>root@VM-4-13-ubuntu:~# cat /proc/sys/vm/swappiness60</code></pre><p>你可以使用以下系统命令动态更改 swappiness 的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@zhao:~# sysctl vm.swappiness=80</span><br><span class="line">vm.swappiness = 80</span><br></pre></td></tr></table></figure><p>这种改变只是暂时的。如果要使其永久化，可以编辑 <code>/etc/sysctl.conf</code> 文件，并在文件末尾添加 swappiness 值:</p><pre><code>vm.swappiness=25</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown教程</title>
      <link href="/2023/11/24/Markdown%E6%95%99%E7%A8%8B/"/>
      <url>/2023/11/24/Markdown%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h1><ol><li>使用 <code>=</code> 和 <code>-</code> 标记一级和二级标题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>#</code> 号标记<br>使用 <code>#</code> 号可表示 1-6 级标题，一级标题对应一个 <code>#</code> 号，二级标题对应两个 <code>#</code> 号，以此类推。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 一级</span><br><span class="line"></span><br><span class="line">## 二级</span><br><span class="line"></span><br><span class="line">### 三级</span><br></pre></td></tr></table></figure><h1 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h1><p><strong>1.段落的换行是使用两个以上空格加上回车</strong></p><p><strong>2.字体</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line"></span><br><span class="line">_斜体文本_</span><br><span class="line"></span><br><span class="line">**粗体文本**</span><br><span class="line"></span><br><span class="line"> __粗体文本__</span><br><span class="line"></span><br><span class="line">***粗斜体文本***</span><br><span class="line"></span><br><span class="line"> ___粗斜体文本___</span><br></pre></td></tr></table></figure><p><strong>3.分割线</strong><br>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">---</span><br><span class="line">222</span><br></pre></td></tr></table></figure><p><strong>4.删除线</strong><br>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <code>~~</code> 即可，实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~11~~</span><br></pre></td></tr></table></figure><p><del>演示效果</del></p><p><strong>5.下划线</strong><br>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br></pre></td></tr></table></figure><p><u>下划线</u></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><strong>1.无序与有序列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序列表使用数字并加上 <code>.</code> 号来表示，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p><strong>2.列表嵌套</strong><br>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><p><strong>1.普通区块</strong><br>Markdown 区块引用是在段落开头使用 <code>&gt;</code> 符号 ，然后后面紧跟一个空格符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块引用</span><br><span class="line">&gt; 区块引用2</span><br><span class="line">&gt; 区块引用3</span><br></pre></td></tr></table></figure><blockquote><p>区块引用<br>区块引用 2<br>区块引用 3</p></blockquote><p><strong>2.区块嵌套</strong><br>一个 <code>&gt;</code> 符号是最外层，两个 <code>&gt;</code> 符号是第一层嵌套，以此类推：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt; &gt; 第一层嵌套</span><br><span class="line">&gt; &gt; &gt; 第二层嵌套</span><br></pre></td></tr></table></figure><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p><strong>3.区块中使用列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; + 第一项</span><br><span class="line">&gt; + 第二项</span><br><span class="line">&gt; + 第三项</span><br></pre></td></tr></table></figure><blockquote><p>区块中使用列表示例</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p><strong>4.列表中使用区块</strong><br>如果要在列表项目内放进区块，那么就需要在 <code>&gt;</code> 前添加四个空格的缩进。</p><ul><li>第一项<blockquote><p>区块 1<br>区块 2</p></blockquote></li><li>第二项<blockquote><p>区块 1<br>区块 2</p></blockquote></li></ul><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p><strong>1.单函数或片段</strong><br>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（&#96;），例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`printf()` 函数</span><br></pre></td></tr></table></figure><p><code>printf()</code> 函数</p><p><strong>2.代码区块</strong><br>代码区块使用 4 个空格或者一个制表符（Tab 键）。<br>你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个链接 [百度](https://www.baidu.com)</span><br></pre></td></tr></table></figure><p>这是一个链接 <a href="https://www.baidu.com/">百度</a></p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>Markdown 图片语法格式如下：</p><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></pre><p>开头一个感叹号 <code>!</code><br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 <code>title</code> 属性的文字。</p><pre><code>![test图片](https://pic.imgdb.cn/item/66018ab59f345e8d0320eb82.jpg &quot;测试图片&quot;)</code></pre><p><img src="https://pic.imgdb.cn/item/66018ab59f345e8d0320eb82.jpg" alt="test图片" title="测试图片"></p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><pre><code>&lt;img src=&quot;https://pic.imgdb.cn/item/66018ab59f345e8d0320eb82.jpg&quot; width=&quot;50%&quot;&gt;</code></pre><img src="https://pic.imgdb.cn/item/66018ab59f345e8d0320eb82.jpg" width="50%"><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| table1 | table2 | table3 |</span><br><span class="line">|  ----  | ----  | ---- |</span><br><span class="line">| test1  | test2 | test3|</span><br><span class="line">| test4  | test5 | test6|</span><br></pre></td></tr></table></figure><p>预览：</p><table><thead><tr><th>table1</th><th>table2</th><th>table3</th></tr></thead><tbody><tr><td>test1</td><td>test2</td><td>test3</td></tr><tr><td>test4</td><td>test5</td><td>test6</td></tr></tbody></table><p><strong>对齐方式</strong></p><p>我们可以设置表格的对齐方式：<br>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><p>预览：</p><table><thead><tr><th align="left">左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">1</td><td align="right">1</td></tr><tr><td align="left">1</td><td align="center">1</td><td align="right">1</td></tr></tbody></table><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>支持的 <code>HTML</code> 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 <code>HTML</code> 撰写。<br>目前支持的 HTML 元素有：</p><pre><code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code></pre><p>例如：</p><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Markdown </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
